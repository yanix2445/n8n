# =============================================================================
# üê≥ DOCKER COMPOSE - Configuration compl√®te pour n8n + PostgreSQL + Cloudflare
# =============================================================================
#
# Ce fichier d√©finit 3 services qui vont tourner ensemble :
# 1. PostgreSQL = Base de donn√©es pour stocker les workflows n8n
# 2. n8n = L'application d'automatisation principale
# 3. cloudflared = Tunnel Cloudflare pour acc√®s HTTPS depuis internet
#
# üìñ COMMANDES UTILES :
# docker-compose up -d          ‚Üí D√©marre tous les services en arri√®re-plan
# docker-compose down           ‚Üí Arr√™te et supprime tous les conteneurs
# docker-compose logs           ‚Üí Voir les logs de tous les services
# docker-compose logs postgres  ‚Üí Voir les logs d'un service sp√©cifique
# docker-compose ps             ‚Üí Voir l'√©tat des services
# =============================================================================

# SERVICES = Nos diff√©rents conteneurs qui vont tourner
services:

  # ==========================================================================
  # üóÑÔ∏è SERVICE 1: POSTGRESQL - Base de donn√©es
  # ==========================================================================
  #
  # PostgreSQL va stocker :
  # - Les workflows n8n que vous cr√©ez
  # - L'historique des ex√©cutions
  # - Les param√®tres et configurations
  #
  postgres:
    # IMAGE = Quelle version de PostgreSQL utiliser
    # "15-alpine" = Version 15 + Alpine Linux (plus l√©ger)
    image: postgres:15-alpine

    # CONTAINER_NAME = Nom du conteneur (optionnel mais pratique)
    container_name: n8n_postgres

    # RESTART = Que faire si le conteneur s'arr√™te ?
    # "unless-stopped" = Red√©marre automatiquement sauf si on l'arr√™te manuellement
    restart: unless-stopped

    # ENVIRONMENT = Variables d'environnement pour configurer PostgreSQL
    environment:
      # Nom de la base de donn√©es √† cr√©er automatiquement
      - POSTGRES_DB=${POSTGRES_DB}

      # Nom d'utilisateur pour la base
      - POSTGRES_USER=${POSTGRES_USER}

      # Mot de passe s√©curis√© depuis le fichier .env
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}

      # Options d'initialisation
      - POSTGRES_INITDB_ARGS=--encoding=UTF8

    # VOLUMES = Stockage persistant des donn√©es
    # Format: nom_du_volume:chemin_dans_le_conteneur
    volumes:
      # Les donn√©es PostgreSQL seront stock√©es dans le volume "postgres_data"
      # M√™me si on supprime le conteneur, les donn√©es restent !
      - postgres_data:/var/lib/postgresql/data

    # HEALTHCHECK = V√©rifier que PostgreSQL fonctionne bien
    # Docker va tester si la base r√©pond toutes les 10 secondes
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U n8n_user -d n8n_database"]
      interval: 10s    # Teste toutes les 10 secondes
      timeout: 5s      # Attend 5 secondes maximum pour une r√©ponse
      retries: 5       # Essaie 5 fois avant de d√©clarer le service "unhealthy"
      start_period: 30s # Attend 30s avant de commencer les tests

    # NETWORKS = Dans quel r√©seau ce conteneur va communiquer
    networks:
      - n8n_network

  # ==========================================================================
  # ü§ñ SERVICE 2: N8N - Application d'automatisation
  # ==========================================================================
  #
  # n8n est l'application principale qui permet de :
  # - Cr√©er des workflows d'automatisation
  # - Connecter diff√©rentes applications (Google Sheets, Slack, etc.)
  # - Ex√©cuter des t√¢ches automatiquement
  #
  n8n:
    # IMAGE = Version officielle de n8n
    image: docker.n8n.io/n8nio/n8n:latest

    # NOM du conteneur
    container_name: n8n_app

    # Red√©marrage automatique
    restart: unless-stopped

    # PORTS = Rendre n8n accessible depuis votre PC
    # Format: port_sur_votre_pc:port_dans_le_conteneur
    ports:
      - "5678:5678"  # n8n sera accessible sur https://localhost:5678

    # VARIABLES D'ENVIRONNEMENT = Configuration de n8n
    environment:
      # === CONFIGURATION DE BASE ===
      - N8N_HOST=yanix-n8n.cloud              # Domaine public
      - N8N_PORT=5678                         # Port interne du conteneur
      - N8N_PROTOCOL=https                     # HTTPS via Cloudflare
      - NODE_ENV=production                    # Mode production
      - WEBHOOK_URL=https://yanix-n8n.cloud   # URL de base pour webhooks (sans port = 443 par d√©faut)

      # === PERFORMANCE & SCALABILIT√â (2024/2025) ===
      - N8N_DEFAULT_BINARY_DATA_MODE=filesystem  # Stockage optimis√© des fichiers
      - EXECUTIONS_MODE=queue          # Mode queue pour haute performance
      - QUEUE_BULL_REDIS_HOST=redis    # Redis pour la queue (ajoutera service Redis)
      - QUEUE_BULL_REDIS_PORT=6379     # Port Redis standard
      - EXECUTIONS_PROCESS=main        # Processus principal pour les ex√©cutions

      # === CONCURRENCE ET LIMITES ===
      - N8N_CONCURRENCY_PRODUCTION=10 # 10 workflows simultan√©s max
      - EXECUTIONS_DATA_MAX_AGE=168    # Garde les ex√©cutions 7 jours (168h)
      - EXECUTIONS_DATA_PRUNE=true     # Nettoyage automatique
      - EXECUTIONS_DATA_PRUNE_MAX_COUNT=10000  # Max 10k ex√©cutions stock√©es

      # === CONNEXION √Ä LA BASE DE DONN√âES ===
      - DB_TYPE=postgresdb             # Utilise PostgreSQL
      - DB_POSTGRESDB_HOST=postgres    # Nom du service PostgreSQL (pas l'IP !)
      - DB_POSTGRESDB_PORT=5432        # Port standard PostgreSQL
      - DB_POSTGRESDB_DATABASE=${POSTGRES_DB}  # Nom de la base (m√™me que dans postgres)
      - DB_POSTGRESDB_USER=${POSTGRES_USER}    # Utilisateur (m√™me que dans postgres)
      - DB_POSTGRESDB_PASSWORD=${POSTGRES_PASSWORD}  # Mot de passe (m√™me que postgres)

      # === S√âCURIT√â ===
      - N8N_BASIC_AUTH_ACTIVE=true     # Active l'authentification
      - N8N_BASIC_AUTH_USER=${N8N_BASIC_AUTH_USER}      # Nom d'utilisateur pour se connecter
      - N8N_BASIC_AUTH_PASSWORD=${N8N_BASIC_AUTH_PASSWORD}  # Mot de passe s√©curis√©
      - N8N_ENCRYPTION_KEY=${N8N_ENCRYPTION_KEY}  # Cl√© pour chiffrer les donn√©es sensibles
      - N8N_SECURE_COOKIE=true         # Cookies s√©curis√©s (HTTPS)
      - N8N_BLOCK_ENV_ACCESS_IN_NODE=true  # Bloque l'acc√®s aux variables d'env dans les nodes

      # === LOGGING & MONITORING (Production 2024/2025) ===
      - N8N_LOG_LEVEL=info             # Niveau de log optimal pour production
      - N8N_LOG_OUTPUT=console,file    # Logs dans console ET fichier
      - N8N_LOG_FILE_LOCATION=/home/node/.n8n/logs/  # Dossier des logs
      - N8N_METRICS_ENABLE=true        # Active les m√©triques (si support√©)

      # === TIMEZONE ===
      - GENERIC_TIMEZONE=${TIMEZONE}  # Fuseau horaire depuis .env
      - TZ=${TIMEZONE}

      # === FEATURES AVANC√âES 2024/2025 ===
      - N8N_TEMPLATES_ENABLED=true     # Active les templates
      - N8N_ONBOARDING_FLOW_DISABLED=true  # D√©sactive l'onboarding en production
      - N8N_PERSONALIZATION_ENABLED=false  # D√©sactive tracking perso en production
      - N8N_VERSION_NOTIFICATIONS_ENABLED=false  # Pas de notifs de version
      - N8N_HIRING_BANNER_ENABLED=false    # Pas de banni√®re de recrutement

    # VOLUMES = Stockage des donn√©es n8n
    volumes:
      # Stockage des workflows, param√®tres, fichiers
      - n8n_data:/home/node/.n8n

      # Dossier pour partager des fichiers avec n8n
      - ./files:/files

      # Volume pour les logs (nouveau 2024/2025)
      - n8n_logs:/home/node/.n8n/logs

    # RESOURCE LIMITS = Limites CPU/RAM (Production 2024/2025)
    deploy:
      resources:
        limits:
          cpus: '2.0'        # Max 2 CPU cores
          memory: 2G         # Max 2GB RAM
        reservations:
          cpus: '0.5'        # Reserve 0.5 CPU
          memory: 512M       # Reserve 512MB RAM

    # DEPENDS_ON = n8n ne d√©marre QUE si PostgreSQL et Redis sont en bonne sant√©
    depends_on:
      postgres:
        condition: service_healthy  # Attend que le healthcheck de postgres passe
      redis:
        condition: service_healthy  # Attend que Redis soit pr√™t

    # HEALTHCHECK = V√©rifier que n8n r√©pond
    healthcheck:
      test: ["CMD-SHELL", "wget --no-verbose --tries=1 --spider http://localhost:5678/healthz || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s  # n8n met plus de temps √† d√©marrer

    # R√âSEAU
    networks:
      - n8n_network

  # ==========================================================================
  # üöÄ SERVICE 4: REDIS - Queue pour haute performance (2024/2025)
  # ==========================================================================
  #
  # Redis permet :
  # - Queue des workflows pour haute performance
  # - Ex√©cution asynchrone des t√¢ches
  # - Scalabilit√© horizontale avec workers
  # - Gestion des pics de charge
  #
  redis:
    # IMAGE Redis Alpine (l√©g√®re et rapide)
    image: redis:7-alpine

    # NOM du conteneur
    container_name: n8n_redis

    # Red√©marrage automatique
    restart: unless-stopped

    # COMMANDE avec persistance des donn√©es
    command: redis-server --appendonly yes --maxmemory 256mb --maxmemory-policy allkeys-lru

    # VOLUMES pour persistance Redis
    volumes:
      - redis_data:/data

    # RESOURCE LIMITS pour Redis
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
        reservations:
          cpus: '0.1'
          memory: 128M

    # HEALTHCHECK Redis
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

    # R√âSEAU
    networks:
      - n8n_network

  # ==========================================================================
  # ‚ö° SERVICE 5: N8N WORKER - Scalabilit√© horizontale (2024/2025)
  # ==========================================================================
  #
  # Le Worker n8n permet :
  # - Traitement parall√®le des workflows
  # - Scalabilit√© horizontale (plusieurs workers)
  # - R√©partition de la charge
  # - Performance maximale
  #
  n8n-worker:
    # M√äME IMAGE que n8n principal
    image: docker.n8n.io/n8nio/n8n:latest

    # NOM du conteneur worker
    container_name: n8n_worker_1

    # Red√©marrage automatique
    restart: unless-stopped

    # COMMANDE = Lance en mode worker
    command: n8n worker

    # VARIABLES D'ENVIRONNEMENT = Configuration identique √† n8n principal
    environment:
      # === CONFIGURATION IDENTIQUE AU MAIN ===
      - NODE_ENV=production
      - GENERIC_TIMEZONE=${TIMEZONE}
      - TZ=${TIMEZONE}

      # === BASE DE DONN√âES (m√™me config) ===
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_HOST=postgres
      - DB_POSTGRESDB_PORT=5432
      - DB_POSTGRESDB_DATABASE=${POSTGRES_DB}
      - DB_POSTGRESDB_USER=${POSTGRES_USER}
      - DB_POSTGRESDB_PASSWORD=${POSTGRES_PASSWORD}

      # === REDIS QUEUE (m√™me config) ===
      - EXECUTIONS_MODE=queue
      - QUEUE_BULL_REDIS_HOST=redis
      - QUEUE_BULL_REDIS_PORT=6379

      # === ENCRYPTION (m√™me cl√©) ===
      - N8N_ENCRYPTION_KEY=${N8N_ENCRYPTION_KEY}

      # === LOGGING WORKER ===
      - N8N_LOG_LEVEL=info
      - N8N_LOG_OUTPUT=console

    # VOLUMES = Stockage partag√©
    volumes:
      - n8n_data:/home/node/.n8n
      - ./files:/files

    # RESOURCE LIMITS pour le Worker
    deploy:
      resources:
        limits:
          cpus: '1.0'        # Max 1 CPU core par worker
          memory: 1G         # Max 1GB RAM par worker
        reservations:
          cpus: '0.25'       # Reserve 0.25 CPU
          memory: 256M       # Reserve 256MB RAM

    # DEPENDS_ON = Worker d√©marre apr√®s que tout soit pr√™t
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      n8n:
        condition: service_healthy  # Attend que n8n principal soit pr√™t

    # HEALTHCHECK Worker
    healthcheck:
      test: ["CMD-SHELL", "ps aux | grep 'n8n worker' | grep -v grep || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s

    # R√âSEAU
    networks:
      - n8n_network

  # ==========================================================================
  # üåê SERVICE 6: CLOUDFLARE TUNNEL - Acc√®s HTTPS depuis Internet
  # ==========================================================================
  #
  # Cloudflare Tunnel permet :
  # - D'exposer votre n8n sur Internet avec HTTPS automatique
  # - Pas besoin d'ouvrir de ports sur votre routeur
  # - Protection DDoS gratuite de Cloudflare
  # - Certificat SSL automatique
  #
  # ‚ö†Ô∏è  PR√âREQUIS : Vous devez avoir :
  # 1. Un domaine configur√© sur Cloudflare
  # 2. Un tunnel cr√©√© sur Cloudflare Dashboard
  # 3. Le token du tunnel
  #
  cloudflared:
    # IMAGE officielle de Cloudflare
    image: cloudflare/cloudflared:latest

    # NOM du conteneur
    container_name: n8n_cloudflared

    # Red√©marrage automatique
    restart: unless-stopped

    # COMMANDE = Lance le tunnel avec le token
    command: tunnel --no-autoupdate run

    # VARIABLES D'ENVIRONNEMENT
    environment:
      # TOKEN du tunnel Cloudflare depuis le fichier .env
      - TUNNEL_TOKEN=${CLOUDFLARE_TUNNEL_TOKEN}

    # DEPENDS_ON = Le tunnel ne d√©marre que si n8n fonctionne
    depends_on:
      n8n:
        condition: service_healthy

    # HEALTHCHECK = V√©rifier que le tunnel fonctionne
    healthcheck:
      test: ["CMD-SHELL", "ps aux | grep cloudflared | grep -v grep || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

    # R√âSEAU = Utilise le r√©seau de l'h√¥te pour acc√©der √† localhost
    network_mode: host

# =============================================================================
# üíæ VOLUMES - Stockage persistant des donn√©es
# =============================================================================
#
# Les volumes permettent de sauvegarder les donn√©es m√™me si on supprime les conteneurs
# Format: nom_du_volume: configuration
#
volumes:
  # Volume pour les donn√©es PostgreSQL (base de donn√©es)
  postgres_data:
    driver: local  # Stockage local sur votre PC
    name: n8n_postgres_data  # Nom explicite du volume

  # Volume pour les donn√©es n8n (workflows, param√®tres, fichiers)
  n8n_data:
    driver: local
    name: n8n_app_data

  # Volume pour les logs n8n (2024/2025)
  n8n_logs:
    driver: local
    name: n8n_logs_data

  # Volume pour les donn√©es Redis (queue)
  redis_data:
    driver: local
    name: n8n_redis_data

# =============================================================================
# üåê NETWORKS - Communication entre conteneurs
# =============================================================================
#
# Le r√©seau permet aux conteneurs de communiquer entre eux
# Par exemple: n8n peut parler √† postgres via le nom "postgres"
#
networks:
  n8n_network:
    driver: bridge  # Type de r√©seau (bridge = r√©seau interne Docker)
    name: n8n_network  # Nom explicite du r√©seau
